using HarmonyLib;
using StardewModdingAPI;
using System.Reflection;
using System.Reflection.Emit;

namespace AnalogMovement.Patches;
internal class ControllerInputPatch
{
    private static IMonitor? Monitor;

    internal static void Initialize(IMonitor monitor, Harmony harmony)
    {
        Monitor = monitor;

        // Search for the delegate used in UpdateControlInput since
        // the name of the class is generated by the compiler
        MethodInfo? updateControlInputDelegate = null;
        foreach (var nestedType in typeof(StardewValley.Game1).GetNestedTypes(AccessTools.all))
        {
            foreach (var methodName in AccessTools.GetMethodNames(nestedType))
            {
                if (methodName.StartsWith("<UpdateControlInput>"))
                {
                    Monitor.Log($"Found UpdateControlInput delegate in Type: {nestedType.Name} Method Name: {methodName}", LogLevel.Trace);
                    updateControlInputDelegate = AccessTools.Method(nestedType, methodName);
                    break;
                }
            }
        }
        if (updateControlInputDelegate == null)
        {
            Monitor.Log("UpdateControlInput delegate was not found! Deadzone config will not work properly.", LogLevel.Error);
            return;
        }

        harmony.Patch(
            original: updateControlInputDelegate!,
            transpiler: new HarmonyMethod(typeof(ControllerInputPatch), nameof(UpdateControlInputDelegate_Transpiler))
        );
    }

    /// <summary>Patch the default deadzone of 0.2 to use the Deadzone field in the ModConfig</summary>
    private static IEnumerable<CodeInstruction> UpdateControlInputDelegate_Transpiler(IEnumerable<CodeInstruction> instructions)
    {
        var codeMatcher = new CodeMatcher(instructions);
        codeMatcher.MatchEndForward(
                new CodeMatch(OpCodes.Ldfld),
                new CodeMatch(OpCodes.Conv_R8),
                new CodeMatch(instruction => instruction.LoadsConstant(0.2) || instruction.LoadsConstant(-0.2))
            )
            .Repeat(cm =>
            {
                var startPos = cm.Pos;
                var originalDeadzone = cm.Operand;
                Monitor!.Log($"Found Load Double Constant at {startPos} with operand {originalDeadzone}", LogLevel.Trace);

                // Load ModEntry.Config
                cm.SetAndAdvance(OpCodes.Ldsfld, AccessTools.Field(typeof(ModEntry), nameof(ModEntry.Config)));
                // Call getter for ModConfig.Deadzone
                cm.InsertAndAdvance(new CodeInstruction(
                    OpCodes.Call,
                    AccessTools.Property(typeof(ModConfig), nameof(ModConfig.Deadzone)).GetGetMethod()!
                ));
                if ((double)originalDeadzone < 0)
                {
                    // Negate deadzone to match original
                    cm.InsertAndAdvance(new CodeInstruction(OpCodes.Neg));
                }
            });
        return codeMatcher.Instructions();
    }
}